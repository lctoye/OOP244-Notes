
<!DOCTYPE html PUBLIC
    '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html lang="en-us" xmlns='http://www.w3.org/1999/xhtml'>
<head>
    <title>Inheritance | Derived Classes</title>

    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta http-equiv="PICS-Label" content='(PICS-1.1 "http://www.icra.org/ratingsv02.html" l gen true r (cz 1 lz 1 nz 1 oz 1 vz 1) "http://www.rsac.org/ratingsv01.html" l gen true r (n 0 s 0 v 0 l 0) "http://www.classify.org/safesurf/" l gen true r (SS~~000 1))' />

    <meta name="Copyright" content="(c) Copyright Chris Szalwinski and Seneca College 2016" />
    <meta name="Description" content="Welcome to the ICT Programming Stream C++ Web Site.  On this site you can find the introductory course to object-oriented programming.  Designed by Chris Szalwinski." />
    <meta name="Abstract" content="This subject introduces the principles of object-oriented programming.  Students study the solution of problems using objects with the C++ programming language.  The emphasis throughout is on the solution of small problems."/>
    <meta name="Author" content="chris.szalwinski@senecacollege.ca"/>
    <meta name="Keywords" content="software development, object-oriented programming, lecture notes"/>

    <link rel="stylesheet" type="text/css" href="../style.043.css">
    <link rel="stylesheet" type="text/css" href="../styleSPrint.043.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylePPrint.043.css" media="print">
</head>

<body>

<table cellspacing="0" cellpadding="0" summary="banner">

    <!-- Body Cell -->
    <tr class="content">
        <!-- Content Area -->
        <td class="tbody">
    <table cellpadding="10" width="100%" summary="content">
     <tr>
      <td class="content" valign="top">
       <br />

       <div class="center">
        <span class="texth">Part D - Inheritance</span>
        <br />
        <br />
        <span class="texthead">Derived Classes</span>
        <br />
        <br />
        <span class="textagend">
        Relate classes using inheritance hierarchies to minimize the duplication of object code
        <br />
        Introduce the terminology and syntax of derived classes
        <br />
        Specify access to the protected members of a base class</span>

        <p class="quote">"Public inheritance must always model 'is-a' ('works-like-a')" (Liskov, 1988)<br />
        "In correct inheritance, a derived class models a special case of a more general ... concept"<br /> (Sutter, Alexandrescu, 2005)</p>
        <span class="textagend">
        <a href="inher_p.html#inh">Hierarchies</a>
        | <a href="inher_p.html#der">Definition</a>
        | <a href="inher_p.html#pro">Access</a>
        | <a href="inher_p.html#sum">Summary</a>
        | <a href="inher_p.html#exe">Exercises</a>
        </span>
       </div>
       <br />
       <br />

       <p>
       Object-oriented languages implement reusability of coding structure through inheritance.&nbsp;
       <i>Inheritance</i> is the second most prominent concept next to encapsulation.&nbsp;
       It refers to the relationship between classes where one class inherits the entire
       structure of another class.&#160; Inheritance is naturally hierarchical, a tighter
       relationship than composition and the most highly coupled relationship after friendship.&#160;</p>

       <p>
       This chapter introduces the terminology used to describe an inheritance relationship and
       the syntax for defining a class that inherits the structure of another class.&nbsp;
       This chapter includes specification of accessibility privileges between classes within
       a hierarchy.&nbsp;
       </p>

       <br />

       <p id="inh" class="section">Hierarchies</p>

       <p>
       A comprehensive example of inheritance relationships is the Linnaean
       Hierarchy in Biology (a small portion is shown below).&#160; The Linnaean
       hierarchy relates all biological species in existence to one another.&#160; Proceeding
       from the bottom of the hierarchy, we identify a human as a Homo, which is a Hominidae, which is a
       Primate, which is a Mammal, which is a Chordata, which is an Animal.&#160;
       Similarly a dog is a Canis, which is a Canidae, which is a Carnivora, which
       is a Mammal, which is a Chordata, which is an Animal.</p>

       <p class="center"><img src="../images/linnaeus.png" width="352"
       height="208" alt="linnean hierarchy" /></p>

       <p>Carl Linnaeus earned himself the title of Father of Taxonomy after developing
       this hierarchy.&#160; He grouped the genera of Biology into higher taxa based on
       shared similarities.&#160; Using his taxa along with modern refinements, we say that
       the <em>genus</em> Homo, which includes the <em>species</em> Sapiens, belongs
       to the <em>Family</em> Hominidae, which belongs to the <em>Order</em> Primates,
       which belongs to the <em>Class</em> Mammalia, which belongs to the
       <em>Phylum</em> Chordata, which belongs to the <em>Kingdom</em> Animalia.&#160;
       For more details see the <a href=
       "http://animaldiversity.ummz.umich.edu/site/accounts/information/Animalia.html">
       University of Michigan Museum of Zoology's Animal Diversity Site</a>.</p>
       <br />

       <p class="ssection">Inheritance in Hierarchies</p>

       <p>Inheritance is a <em>transitive</em> structural relationship.&#160; A
       human inherits the structure of a Homo, which inherits the structure of a Hominoid,
       which inherits the structure of a Primate, which inherits the structure of a Mammal,
       which inherits the structure of a Chordata, which inherits the structure of an
       Animal.&#160;</p>

       <p>Inheritance is <em>not
       commutative</em>.&#160; A Primate is an Animal, but an Animal
       is not necessarily a Primate: dogs and foxes are not
       Primates.&#160; Primates have highly developed hands and feet,
       shorter snouts and larger brains than dogs and foxes.&#160;</p>

       <p class="ssection">Terminology</p>

       <p class="sssection">is a kind of</p>

       <p>
       The relative position of two classes in a hierarchy identifies their inheritance
       relationship.&nbsp; A class lower in the hierarchy <em>is a kind of</em> the class
       that is higher in the hierarchy.&#160; For example, a
       dog <em>is a kind of</em> canis, a fox <em>is a kind of</em> Vulpes
       and a human <em>is a kind of</em> Homo.&#160; In our course example from the first
       chapter, a <span class="code">Hybrid Course</span> <em>is a kind of</em> <span class=
       "code">Course</span>.&#160;
       </p>
       <p>
       We depict an inheritance relationship by an arrow pointed to the inherited class.&#160; </p>

       <p class="center"><img src="../images/isahierarchy.png" width=
       "61" height="73" alt="is a kind of hierarchy" /></p>

       <p>The <span class="code">Hybrid Course</span> class inherits the entire
       structure of the <span class="code">Course</span> class.&#160;
       </p>

       <p class="sssection">Derived and Base Classes</p>

       <p>
       We call the child in an is-a-kind-of relationship the <i>derived class</i> and
       we call the parent in the relationship the <i>base class</i>; that is, the <span class="code">Hybrid Course</span>
       class is a derived class of the <span class="code">Course</span> base class.&#160;
       A derived class is lower in the hierarchy, while its base class is
       higher in the hierarchy.&nbsp; The derived class inherits the entire structure
       of its base class.&#160;
       </p>

       <p>The inheritance arrow extends from the derived class to the base class:</p>

       <p class="center"><img src="../images/inherit&#32;arrow.png" width="198" height="76" alt=
       "inheritance arrow" /></p>

       <p>
       We depict an object of a derived class by placing its instance variables
       after the instance variables of its base class in the direction of increasing
       addresses in memory:</p>

       <p class="center"><img src="../images/inherit&#32;object.png" width="127" height="80" alt=
       "object representation" /></p>

       <p>
       A derived class object contains the instance variables of the
       base class and those of the derived class, while a base class
       object only contains the instance variables of the base class.&nbsp;
       </p>

       <p>
       The terms base class and derived class are C++ specific.&nbsp; Equivalent terms
       for these object-oriented concepts include:
       </p>
       <ul>
       <li>base class - super class, parent class</li>
       <li>derived class - subclass, heir class, child class</li>
       </ul>

       <p class="ssection">Inherited Structure</p>

       <p>A derived class contains all of the instance variables and
       all of the normal member functions of its base class in addition to its
       own instance variables and member functions.&#160; A derived class does
       not inherit the base class' special functions: constructors, destructors
       or assignment operators.&nbsp; The term <i>normal member function</i>
       excludes these <em>special</em> member functions.&nbsp;</p>
       <br />

       <p id="der" class="section">Definition of a Derived Class</p>

       <p>The definition of a derived class takes the form</p>
       <pre class="defin">
class <i>Derived</i> : <i>access Base</i> {

    // ...

};
</pre>
       <p>where <span class="code"><i>Derived</i></span> is the name of
       the derived class and <span class="code"><i>Base</i></span> is the name of
       the base class.&nbsp; <span class="code"><i>access</i></span>
       identifies the access that member functions of the
       derived class have to the non-private members of the base
       class.&#160; The default access is <span class="code">private</span>.&#160;
       The most common access is <span class="code">public</span>.&#160;</p>

       <p class="ssection">Example</p>

       <p>
       A <span class=code>Student</span> is a kind of <span class=code>Person</span>.&nbsp;
       Every <span class=code>Person</span> has a name.&nbsp; Accordingly, let us derive our
       <span class=code>Student</span> class from a <span class=code>Person</span> class,
       where the <span class=code>Person</span> class includes an instance variable
       that holds a name in the form of a character string.&nbsp;
       </p>
       <p>
       The header file for our <span class=code>Student</span> class contains our definitions
       of the base and derived classes:
       </p>

       <table width="45%" summary="">
        <tr>
         <td>
          <pre>
 // Student.h

 #include &lt;iostream&gt;
 <span class="high">const int NC = 30;</span>
 const int NG  = 20;

 <span class="high">class Person {                   // start of Base Class Definition
     char name[NC+1];
   public:
     void set(const char* n);
     void displayName(std::ostream&) const;
 };                              // end of Base Class Definition</span>

 class Student <span class="high">: public Person</span> { // start of Derived Class Definition&nbsp;
     int no;
     float grade[NG];
     int ng;
   public:
     Student();
     Student(int);
     Student(int, const float*, int);
     void display(std::ostream&) const;
 };                              // end of Derived Class definition
</pre>
         </td>
        </tr>
       </table>

       <p>
       The implementation file defines the member functions:
       </p>

       <table width="45%" summary="">
        <tr>
         <td>
          <pre>
 // Student.cpp

 #include &lt;cstring&gt;
 #include "Student.h"
 using namespace std;

 <span class="high">void Person::set(const char* n) {
     strncpy(name, n, NC);
     name[NC] = '\0';
 }

 void Person::displayName(std::ostream& os) const {&nbsp;
     os &lt;&lt; name &lt;&lt; ' ';
 }</span>

 Student::Student() {
     no = 0;
     ng = 0;
 }

 Student::Student(int n) {
     float g[] = {0.0f};
     *this = Student(n, g, 0);
 }

 Student::Student(int sn, const float* g, int ng_) {&nbsp;
     bool valid = sn &gt; 0 && g != nullptr && ng_ &gt;= 0;
     if (valid)
         for (int i = 0; i &lt; ng_ && valid; i++)
             valid = g[i] &gt;= 0.0f &amp;&amp; g[i] &lt;= 100.0f;

     if (valid) {
         // accept the client's data
         no = sn;
         ng = ng_ &lt; NG ? ng_ : NG;
         for (int i = 0; i &lt; ng; i++)
             grade[i] = g[i];
     } else {
         *this = Student();
     }
 }

 void Student::display(<span class="high">std::ostream&amp; os</span>) const {
     if (no &gt; 0) {
         os &lt;&lt; no &lt;&lt; ":\n";
         os.setf(ios::fixed);
         os.precision(2);
         for (int i = 0; i &lt; ng; i++) {&nbsp;
             os.width(6);
             os &lt;&lt; grade[i] &lt;&lt; endl;
         }
         os.unsetf(ios::fixed);
         os.precision(6);
     } else {
         os &lt;&lt; "no data available" &lt;&lt; endl;&nbsp;
     }
 }
</pre>
         </td>
        </tr>
       </table>

       <p>
       The following client code uses this implementation to produce the results on the right:
       </p>

       <table width="95%" summary="">
        <tr>
         <td class="w70">
          <pre>
 // Derived Classes
 // derived.cpp

 #include &lt;iostream&gt;
 #include "Student.h"

 int main() {
     float gh[] = {89.4f, 67.8f, 45.5f};
     Student harry(1234, gh, 3);
     <span class="high">harry.set("Harry");           // inherited
     harry.displayName(std::cout); // inherited </span>
     harry.display(std::cout);     // not inherited
 }
</pre>
         </td>

         <td class="w30">
          <pre class="result">









 Harry 1234:&nbsp;
  89.40
  67.80
  45.50
</pre>
         </td>
        </tr>
       </table>

       <p>
       Note that the <span class="code">main()</span> function refers
       to the <span class="code">Student</span> type, without
       referring to the <span class=code>Person</span> type.&#160;
       Here, the hierarchy itself is invisible to the
       client code.&nbsp; We can upgrade the hierarchy without
       having to alter the client code in any way.&nbsp;</p>
       <br />

       <p id="pro" class="section">Access</p>

       <p>
       The C++ language supports three modifiers for granting access to the
       members of class:</p>

       <ul>
        <li><span class="code">private</span> - bars all access</li>

        <li><span class="code">protected</span> - limits access to derived
        classes only</li>

        <li><span class="code">public</span> - unlimited access</li>
       </ul>

       <p>
       Since the data member of the <span class="code">Person</span> class is
       <span class="code">private</span>, the member functions of our
       <span class="code">Student</span> class and the client code cannot
       access that data member.&#160; Since the member functions of the <span class=code>Person</span>
       and <span class="code">Student</span> classes are <span class="code">public</span>,
       the  <span class="code">main()</span> function can access all of them.&#160;
       </p>

       <p class="ssection">Limiting Access to Derived Classes</p>

       <p>
       The keyword <span class=code>protected</span> limits access to members
       of a derived class.&nbsp;
       </p>
       <p>
       For example, let us limit access to <span class=code>displayName()</span>
       to classes derived for the <span class=code>Person</span> class.&#160;
       Then, the <span class=code>main()</span> function
       cannot call this member function and we must call it directly from
       <span class=code>Student::display()</span>.&#160; The header file limits the
       access:</p>
       <table width="45%" summary="">
        <tr>
         <td>
          <pre>
 // Student.h

 #include &lt;iostream&gt;
 const int NC = 30;
 const int NG = 20;

 class Person {
     char name[NC+1];
   public:
     void set(const char* n);
   <span class="high">protected:
     void displayName(std::ostream&) const;</span>&nbsp;
 };

 class Student : public Person {
     int no;
     float grade[NG];
     int ng;
   public:
     Student();
     Student(int);
     Student(int, const float*, int);
     void display(std::ostream&) const;
 };
</pre>
         </td>
        </tr>
       </table>

       <p>
       Our implementation of <span class=code>Student::display()</span> calls
       <span class=code>displayName()</span> directly:
       </p>

       <table width="45%" summary="">
        <tr>
         <td>
          <pre>
 // Student.cpp

 #include &lt;cstring&gt;
 #include "Student.h"
 using namespace std;

 void Person::set(const char* n) {
     strncpy(name, n, NC); // validates length&nbsp;
     name[NC] = '\0';
 }

 void Person::displayName(std::ostream& os) const {
     os &lt;&lt; name &lt;&lt; ' ';
 }

 Student::Student() {
     no = 0;
     ng = 0;
 }

 Student::Student(int n) {
     float g[] = {0.0f};
     *this = Student(n, g, 0);
 }

 Student::Student(int sn, const float* g, int ng_) {&nbsp;
     bool valid = sn &gt; 0 && g != nullptr && ng_ &gt;= 0;
     if (valid)
         for (int i = 0; i &lt; ng_ && valid; i++)
             valid = g[i] &gt;= 0.0f &amp;&amp; g[i] &lt;= 100.0f;

     if (valid) {
         // accept the client's data
         no = sn;
         ng = ng_ &lt; NG ? ng_ : NG;
         for (int i = 0; i &lt; ng; i++)
             grade[i] = g[i];
     } else {
         *this = Student();
     }
 }

 void Student::display(std::ostream&amp; os) const {
     if (no &gt; 0) {
         <span class=high>displayName(os);</span>
         os &lt;&lt; no &lt;&lt; ":\n";
         os.setf(ios::fixed);
         os.precision(2);
         for (int i = 0; i &lt; ng; i++) {&nbsp;
             os.width(6);
             os &lt;&lt; grade[i] &lt;&lt; endl;
         }
         os.unsetf(ios::fixed);
         os.precision(6);
     } else {
         os &lt;&lt; "no data available" &lt;&lt; endl;&nbsp;
     }
 }
</pre>
         </td>
        </tr>
       </table>

       <p>
       We refer to <span class=code>displayName()</span> directly without any scope
       resolution as if this function is a member of our <span class=code>Student</span>
       class.&nbsp;
       </p>

       <p>
       The following client code produces the output shown on the right:
       </p>

       <table width="95%" summary="">
        <tr>
         <td class="w70">
          <pre>
 // Protected Access
 // protected.cpp

 #include &lt;iostream&gt;
 #include "Student.h"

 int main() {
     float gh[] = {89.4f, 67.8f, 45.5f};
     Student harry(1234, gh, 3);
     harry.set("Harry");           // inherited
     harry.display(std::cout);     // not inherited
 }
</pre>
         </td>

         <td class="w30">
          <pre class="result">








 Harry 1234:&nbsp;
  89.40
  67.80
  45.50
</pre>
         </td>
        </tr>
       </table>

       <p class="ssection">Avoid Granting Protected Access to Data Members</p>

       <p>
       Granting data members protected access introduces a security hole.&nbsp;
       If a derived class has protected access to any data member of its base
       class, any member function of the derived class can circumvent any validation
       procedure in the base class.&#160; If the base class in the above example
       granted client code access to the <span class=code>person</span> data member, we
       could change its contents from our <span class=code>Student</span>
       class to a string of more than <span class=code>NC</span> characters,
       which would probably break our <span class=code>Student</span> object.&#160;
       </p>
       <p class="sssection">Good Design Tip</p>

       <p>
       Granting <span class="code">protected</span> access to any data member
       exposes that member to potential corruption and is considered poor design.&nbsp;
       A protected read-only query is a preferable alternative to protected access to a
       data member.&nbsp; The query does not allow any modification of the value in the
       data member.</p>

       <br />

       <p id="sum" class="section">Summary</p>

       <ul>
        <li>inheritance is a hierarchical relationship between classes.&#160;</li>

        <li>a derived class inherits the entire structure of its base class</li>

        <li>the access modifier <span class=code>protected</span>
        grants access to member functions of the derived class</li>

        <li>any member function of a derived class may access any <span class=code>protected</span>
        or <span class=code>public</span> member of its base class</li>

        <li>keeping a data member <span class=code>private</span> and accessing it
        through a <span class=code>protected</span> query is good design</li>
       </ul>
       <br />

       <p id="exe" class="section">Exercises</p>

       <ul>
        <li>Complete the Handout on <a href="../handouts/h12.html">Derived Classes</a></li>

        <li>Read Wikipedia on <a href="http://en.wikipedia.org/wiki/Inheritance_%28computer_science%29">
         Inheritance</a></li>
       </ul>
       <br />
       <br />
       <br />
      </td>
     </tr>
    </table>
        </td>
    </tr>

    <!-- Footer
    <tr>
        <td class="tbody">
            <table cellpadding="1" width="90%" align="center">
                <tr>
                    <td class="half text3">
                        <script type="text/javascript">
                        var lh = document.location.href;
                        document.write(lh)
                        </script>&nbsp;&nbsp;
                    </td>
                    <td class="half" align="left" class="text3">
                        <script type="text/javascript">
                        var lm = document.lastModified.slice(0,-3);
                        document.write("Last Modified: " +lm)
                        </script>&nbsp;&nbsp;
                    </td>
                </tr>
            </table>
        </td>
    </tr>-->
</table>

</body>
</html>